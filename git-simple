#!/usr/bin/env ruby
# Simple git workflow
# Copyright (c) 2011, Jeremy Tregunna, All Rights Reserved.

require 'getoptlong'
require 'rubygems'
require 'grit'

GIT_SIMPLE_VERSION = "0.1"

class Simple
  attr_accessor :repo
  
  def initialize(path = ".")
    @repo = Grit::Repo.new(path)
  end
  
  def stash(sync = false)
    msg = sync ? 'syncing branch' : 'switching branches'
    repo.git.stash({}, "save", stash_msg(msg))
  end
  
  def unstash_index(sync = false)
    stashes = repo.git.stash({}, 'list').split("\n")
    
    stashes.each do |st|
      verb = sync ? 'syncing' : 'switching'
      return st.gsub(/stash@\{(\d+)\}.*/, "\\1") if /On #{current_branch.name}: git-simple: #{verb}.*/
    end
  end
  
  def unstash(sync = false)
    stash_index = unstash_index(sync)
    
    repo.git.stash({}, 'pop', "stash@{#{stash_index}}") if stash_index
  end
  
  def fetch
    repo.git.fetch({}, remote_name)
  end
  
  def smart_pull
    remote_name = remote_name
    branch = current_branch.name
    
    fetch
    
    merges = repo.git.log({}, '--merges', "#{remote_name}/#{branch}..#{branch}")
    verb = merges.split('commit').size > 0 ? 'merge' : 'rebase'
    repo.git.send(verb.to_sym, {}, "#{remote_name}/#{branch}")
  end
  
  def push(branch_name = nil)
    unless branch_name
      repo.git.push
    else
      repo.git.push({}, remote_name, branch_name)
    end
  end
  
  def checkout_branch(branch_name)
    repo.git.checkout({}, branch_name)
  end
  
  def develop_branch(off_branch_name, branch_name)
    repo.git.checkout({}, off_branch_name, '-b', branch_name)
  end
  
  def graft_branch(branch_name)
    log = []
    
    out = repo.git.merge({}, '--no-ff', branch_name)
    status = $?.exitstatus
    log << out
    
    if status == 0
      out = repo.git.branch({}, '-D', branch_name)
      log << out
      log.join('\n')
    else
      'There was a problem merging, so the branch will not be deleted.'
    end
  end
  
  def unpublish_branch(branch_name)
    repo.git.push({}, remote_name, ":#{branch_name}")
  end
  
  def publish_branch(branch_name)
    repo.git.push({}, remote_name, branch_name)
  end
  
  private
  
  def remote_name(index = 0)
    repo.remotes[index].name.split("/")[0]
  end
  
  def current_branch
    repo.heads.first
  end
  
  def stash_msg(msg)
    "git-simple: stashing before #{msg}."
  end
end

$simple = Simple.new(".")

def usage
  puts 'Usage: git-simple [options]'
  puts '    -h, --help                    this help message'
  puts '    -v, --version                 displays the version'
  puts ''
  puts ' commands:'
  puts '    sync [branch]                 synchronizes branch with remote'
  puts '    switch branch                 changes to branch'
  puts '    develop [from-branch] branch  creates a new branch detached from from-branch'
  puts '    graft branch into-branch      merges branch into into-branch'
  puts '    publish branch                pushes branch to the remote'
  puts '    unpublish branch              deletes branch from the remote'
end

begin
  opts = GetoptLong.new(
    ["--help", "-h", GetoptLong::NO_ARGUMENT],
    ["--version", "-v", GetoptLong::NO_ARGUMENT]
  )

  opts.each do |opt, arg|
    case opt
    when '--help'
      usage
      exit 1
    when '--version'
      puts "git-simple version #{GIT_SIMPLE_VERSION}"
      exit 0
    else
      usage
      exit 1
    end
  end

  usage if ARGV.empty?
rescue GetoptLong::InvalidOption
  usage
  exit 1
end